# 018 알고리즘과 초콜릿 케이크 레시피

- 소프트웨어는 음식을 만드는 레시피와 유사함
    - 요리에 필요한 재료, 수행해야하는 작업 순서, 예상되는 결과를 열거
    - 소프트웨어는 연산에 필요한 데이터를 명시, 데이터에 대해 수행할 작업을 자세히 설명
- 알고리즘(algorithm)은결과를 정확하게 계산하도록 보장된 일련의 단계
    - 한치의 모호함도 있어서는 안된다
    - 입력 데이터가 어떤 유형인지
    - 모든 가능한 상황을 다루어야 하고, 다음에 무엇을 해야 할 지 모르는 상황이 발생하면 안됨
    - 언젠가는 멈춰야함
    - 지능이나 상상력이 없는 개체가 수행하더라도 연산의 의미와 수행 방법에 의심의 여지가 없을 정도로 상세하고 정확하게 일련의 연산을 명시해야함
    - 알고리즘의 효율성은 처리 데이터 양에 따라 계산에 소요되는 시간을 표현하는 방법

# 019 반에서 가장 키 큰 사람 찾기 : 선형 알고리즘

- 키가 가장 큰 사람을 찾는법
    
    ```
    set max to 0
    for each height on the list
    	if max is smaller than height
    		then max is height
    print max 
    ```
    
    - 중복되는 값이 있을땐?
    - 키가 같은 사람들의 무리 중에서 사람 수가 가장 많은 무리를 찾는 방법은?
    - 자료 구조(data structure) : 계산 과정에서 필요한 정보를 표현하는 방법
    - 알고리즘과 컴퓨터는 모든 가능한 상황을 처리해야함
- 얼마나 효율적으로 작동하느냐가 알고리즘에서 중요한 특성임
- 선형 시간(Linear-time) 계산 시간이 데이터의 양에 정비례하거나 선형적으로 비례함
    - 대부분의 선형 알고리즘이 동일한 기본 형태를 가짐
    ```
    1. 초기화
    2. 각 항목을 차례로 검사하고, 항목에 대해 간단한 계산을 수행
    3. 작업을 끝내기 위한 단계 수행
    ```

# 020 10억개의 전화번호에서 이름 찾기 : 이진 검색

- 정렬되어 있다면 이진 검색을 적용할 수 있음
- 이진 검색(binary search)
    - 각 확인 또는 비교 단계를 거치면서 항목이 두 그룹으로 나뉘고, 한쪽 그룹은 다음 고려 대상에서 제외함.
    - 분할 정복(divide and conquer)이라는 일반적인 전략의 한 가지 예
    - 수행해야하는 일의 양이 데이터의 양이 증가하는 것에 비해 천천히 증가함

# 021 검색을 쉽게 만드는 정렬 : 선택 정렬 vs 퀵 정렬

- 핵심적인 알고리즘 문제인 정렬(sorting)
    - 항목을 순서대로 배열해서 검색이 빨리 실행될 수 있도록 해줌

## 선택 정렬(selection sort)

- 아직 정렬되지 않은 항목 중에서 다음 이름을 계속해서 선택함

```
1. 주어진 배열 중에서 최소값을 찾는다
2. 그 값을 맨 앞에 위치한 값과 교체한다
3. 맨 처음 위치를 뺸 나머지 리스트를 같은 방법으로 교체한다
4. 하나의 원소만 남을 때 까지 위의 1~3 과정을 반복한다
```

- 시간 복잡도는 O(n^2)

## 퀵 정렬(quicksort)

- 분할 정복의 한 사례

```
1. 리스트 안에서 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot)이라 한다
2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고, 
   피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다
3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다
   - 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다
   - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다
4. 부분 리스트들이 더 이상 분할이 불가능할 때 까지 반복한다
	 
```

- 속도가 빠르다.
- 시간 복잡도는 O(nlog_2 n)을 가짐.
- 불균형 분할이 일어나면 오히려 수행시간이 더 오래걸릴수도 있다

# 022 10개 도시를 최단거리로 여행하는 법

- 지수 복잡도(Exponential) : 실생활에서 자주 등장하지만 효율이 특히 낮음
    - 지수 알고리즘은 사실상 모든 가능한 경우를 하나씩 시도해 봐야한 하는 상황에서 발생
- P-NP 문제
    - Polynomial. 다항 시간 내에 해결 가능
    - Nondeterministric Polynomial : 비결정적 다항
    - ex) 여행하는 외판원 문제
        - 아직도 최단 경로를 찾는 방법은 모든 가능한 경로를 시도해 보는 것 밖에 없음
    - 즉, 가능한 모든 해법을 완전 탐색하는 것 보다 더 효율적으로 풀 방법이 없다는 뜻

# 023 요약

- 컴퓨터과학 분야에서는 오랜시간 ‘얼마나 빨리 계산할 수 있는가?’에 관한 개념을 정리함
- 실행 시간을 표현하는 빅 오 표기법(Big-O notation)이 그 결과임
- 알고리즘끼리 비교하거나 어떤 계싼의 실행 가능성을 추론하는 좋은 방법
- 이론상으로는 검색 엔진이 하는 일도 간단함
    - 웹 페이지를 수집하고, 검색하기 쉽게 정보를 조직화 하고, 효율적으로 정보를 검색하는것
    - 그러나 작업의 규모가 엄청나게 크기 때문에, 다양한 알고리즘과 프로그램 기법이 적용됨

# 024 알고리즘은 이상, 프로그램은 현실

- 알고리즘은 추상적이고 이상적인 절차를 기술 한 것, 구현에 필요한 세부사항과 현실적인 고려사항을 무시함
- 프로그램은 실제 컴퓨터가 과제를 완료하기 위해 수행해야 하는 모든 단계를 구체적으로 서술함
    - 하나 이상의 알고리즘이 컴퓨터가 직접 처리할 수 있는 형태로 표현된 것
    - 불충분한 메모리, 제한된 프로세서 속도, 유효하지 않거나 악의적으로 잘못된 데이터 입력, 하드웨어 결함, 네트워크 연결 분량, 휴먼 에러 등의 문제를 고려
- 컴퓨터의 자원 관리 일 또한 어려움. 이는 운영체제가 처리

# 025 다른 프로그램을 처리하기 위한 프로그램

- 최초에는 천공카드를 이용하여 프로그래밍하여, 수정하기 매우 어려웠음
- 에드삭(윌스크) : 1949년 첫 번째 프로그램 내장식 디지털 컴퓨터
    - 다른 프로그램을 처리하기 위한 프로그램
- 어셈블러(assembler) 특정 처리를 수행하는 프로그램.
    - 다른 프로그래머가 사전에 작성했던 프로그램에서 필요한 부분을 모으는 역할을 하기 때문에 붙여진 이름
    - 프로그래머가 명령어를 추가하거나 삭제할 때, 변경 기록을 직접 관리하는 대신, 어셈블러가 각 명령어와 데이터 값이 메모리상 어느 위치에 있는지 파악해줌
    - 특정 프로세서 아키텍처에서 사용되는 어셈블리 언어는 그 아키텍처에 특화된 언어
    - 프로세서 명령어와 일대일로 연결되고, 명령어가 이진수로 인코딩 되는 특정한 방식과 메모리에 정보가 배치되는 방식을 알고 있음

# 026 고수준 언어에서 프로그래밍 실행까지

- 특정 아키텍처에 독립적인 고수준 프로그래밍 언어가 개발됨
    - 고수준 언어로 작성된 코드는 번역기 프로그램(컴파일러)을 통해 대상 프로세서의 어셈블리 언어로 변환되고, 어셈블러에 의해 비트로 변환되어 메모리에 로드되고 실행됨
    - 장점
        1. 사람이 표현하는 방식에 가까운 용어로 계산 과정을 작성할 수 있음
        2. 프로그램을 효율적으로 짜기 위해 특정 프로세서의 명령어 레퍼토리를 알아야 할 필요가 없음
        3. 특정 아키텍처에 종속되지 않음
        4. 컴파일 단계는 몇 가지 명백한 에러를 미리 점검하게 해줌
- 초기에는 컴파일러가 숙련된 어셈블리 언어 프로그래머보다 효율적이지 못하였음

### 포트란Fortran

- Formular Translation 수식 변환에서 유래한 이름
- IBM팀에서 개발하였고, 과학 공학 분야에서 계산을 표현하는데 사용함

### 코볼COBOL

- Common Business Oriented Language
- 사무 데이터 처리 목적으로 사용되었고, 재고 관리, 송장 작성, 급여 계산 등에 사용됨
- 국내 은행권에서 아직도 사용하고있음

### 베이직BASIC

- Beginner’s All-purpose Symbolic Instruction Code
- 프로그래밍 교육을 위한 쉬운 언어
- 개인용 컴퓨터에서 사용할 수 있는 첫 번째 고수준 언어

# 027 작문과 비슷한 프로그래밍

- 포트란, 코볼, 베이직이 성공했던 이유는 특정 응용 분야에 집중했기 때문
- 1970년대부터는 시스템 프로그래밍 용도로, 즉 어셈블러, 컴파일러, 텍스트 편집기 같은 프로그래머 도구와 심지어 운영체제까지 작성할 목적으로 사용할 언어들이 만들어졌음

### C언어

- 1973년 벨 연구소, 데니스 리치가 개발
- 가장 폭 넓게 사용되며 가장 있기있는 언어

### C++

- 1980년대 들어서는 규모가 매우 큰 프로그램의 복잡성 관리를 도울 의도로 설계된 언어들이 개발됨
- 벨 연구소, 비야네 스트로스트룹이 개발
- 대부분의 컴퓨터에서 사용되는 주요 프로그램들이 C, C++, Obj C로 개발되었음

### Java

- 1990년대 WWW 성장에 대응하여 더 많은 언어가 개발되었음.
- 썬 마이크로시스템즈에서  일하던 제임스 고슬링이 개발함
- 초기 자바의 적용 대상은 속도는 그다지 중요하지 않지만 유연성이 중요한 임베디드 시스템 타겟
- 현재 자바는 안드로이드 앱을 작성하는 주요 언어기도 함

### Javascript

- 1995년, 넷스케이프에서 근무하던 브렌던 아이크가 개발
- 자바와는 상관 없음
- 처음부터 웹 페이지의 동적인 효과를 구현하기 위해 브라우저 내부에서 사용할 목적으로 개발됨

### Python

- 1991, 네덜란드 암스테르담의 CWI에서 일하던 귀도 반 로섬이 개발
- 문장을 그룹화 하는데 중괄호 대신 들여쓰기 이용함
- 가독성에 초점을 두고 설계됨

# 028 구글 같은 서비스는 어떻게 개발할까?

- 대규모 프로그래밍은 무엇을 해야할지 파악하고, 넓은 명세부터 시작해서 점차 작은 부분으로 적절히 나누고, 각 부분을 작업하면서 전체적으로 일관되어 있는지 확인해야 한다
- 다른 프로그래머들이 작성한 부분들이 함께 잘 작동하는지 확인하는 일은 어려운데, 이걸 바로잡지 못하면 에러가 발생할 소지가 크다

### 라이브러리, 인터페이스, 개발 키트

- 다른 사람들이 만들어놓은 여러 가지 구성 요소를 바로 구해서 사용함
- 프로그래밍 작업의 대부분은 이미 있는 구성 요소를 이해하고자신만의 방식으로 이어 붙이는 것
- 함수 매커니즘 : 어떤 프로그래머가 유용한 작업을 수행하는 코드를 작성하면, 다른 프로그래머가 그 내부 작동 방식을 모르더라도 프로그램에 사용할 수 있는 형태로 코드를 패키지화
- 연관된 함수들의 모음을 보통 라이브러리라고 함
- 함수 라이브러리가 제공하는 서비스는 애플리캐이션 프로그래밍 인터페이스, 즉 API로 프로그래머에게 제공됨
- 대규모 시스템은 프로그래머들이 복잡한 소프트웨어 라이브러리를 잘 다룰 수 있도록 소프트웨어 개발 키트, 즉 SDK를 포함함

### 버그

- 발생할 수 있는 경우를 깜빡하고 처리하지 못했거나, 어떤 조건을 평가하기 위한 논리 테스트나 산술 테스트를 잘못 작성했거나, 잘못된 공식을 사용했거나, 프로그램이나 프로그램의 특정 부분에 할당된 영역 밖에 있는 메모리에 접근했거나, 특정 종류의 데이터에 잘못된 연산을 적용했거나, 사용자 입력이 적합한지 검사하지 못한 경우 등
- 두 함수가 역함수 관계라면, 두 함수를 차례로 통과시키면 원래 값이 되어야함

# 029 구글과 오라클의 저작권 소송

- 지적 재산권(intellectual property) : 다양한 종류의 무형 자산. 소프트웨어도 지적 재산권 중 하나
- 영업 비밀(trade secret) : 지적재산권은 소유자만 그 비밀을 보유하고, 기밀 유지 협약서 같은 법적 구속력이 있는 계약에 의해서만 다른이에게 공개된다
- 상표(trademark) : 회사의 상품이나 서비스를 구별해주는 단어나 문구, 이름, 로고, 특정 색상 등
- 저작권(copyright) : 창작 표현물을 보호함. 저작권은 다른 이들이 복제하지 못하도록 창작물을 보호하며, 창작자에게 제한된 기간에 걸쳐 작품을 확용하고 수익을 얻을 권리를 줌
- 특허(patent) : 발명에 대한 법적 보호를 제공. 저작권은 표현물만 보호한다면, 특허는 코드가 포함할 수 있는 어떤 독창적인 아이디를 보호함.
    - 특허 괴물(patent troll) : 허가 없이 특허를 침해중인 다른 기업에게 소송을 제기하기 위해 특허에 대한 권리를 취득
- 라이선스(license) : 제품을 사용할 권한을 승인하는 법적 합의.
    - 최종 사용자 라이선스 동의(End User License Agrement : EULA)

# 030 기술 표준의 중요성

- 표준(standard) : 어떤 기술적 산물이 어떻게 만들어지고 어떻게 작동하도록 되어있는지 명확하고 상세하게 기술 한 것
- 보통 정부 기관이나 컨소시엄같은 준중립적 단체에 의해 개발되고 유지됨
- 서로 경쟁관계에 있는 표준도 있음.
- 소프트웨어에도 많은 표준이 있음. ex) 아스키코드, 유니코드 등
- 표준은 상호운용성을 보장하고 공개경쟁이 이루어지도록 하는데 결정적인 요소임

# 031 자유로운 소프트웨어 오픈소스

- 프로그래머가 작성하는 코드는 소스 코드(source code)
- 소스코드를 프로세서에서 실행하기에 적합한 형태로 컴파일 한 결과를 오브젝트 코드(object code)라고 함
- 대부분의 상용 소프트웨어는 오브젝트 코드 형태로만 배포됨
    - 너무 많은 변환 과정을 거쳤기 때문에, 원래 소스코드와 조금이라도 비슷하게 복원하거나, 수정이 대개 불가능하기 때문

### 오픈소스(open source)

- 연구와 개선 활동을 위해 다른 사람들도 소스 코드를 자유롭게 사용할 수 있도록 하는 대안을 일컫는 용어
- 1983년 리처드 스톨만 GNU 프로젝트
    - 중요한 소프트웨어 시스템의 무료 공개 버전을 만드는것
    - 자유 소프트웨어 재단 비영리 단체 개설
    - GNU GPL라이선스에 따라 배포
- GPL은 라이선스가 적용된 소프트웨어를 자유롭게 사용할 수 있다고 명시하는데, 만약 소프트웨어가 다른 누군가에게 배포되면 그 배포판도 똑같이 ‘어떤 용도로 자유로운’ 라이선스를 적용해서 소스코드를 사용할 수 있게 해야한다.
- GNU 프로젝트는 기업, 단체, 개인에게서 지원을 받고, 수많은 프로그램 개발 도구와 애플리케이션을 만들어냄
- 리눅스 운영체제도 오픈소스 프로젝트

# 032 요약

- 프로그래밍 언어는 컴퓨터에 무엇을 해야할 지 알려줄 때 쓰는 언어
- 어떤 언어도 단독으로 모든 프로그래밍 과제에 이상적이지는 않음
- 프로그래밍 언어는 꾸준히 증가하는 하드웨어 자원을 활용하도록 진화하였음
- 소프트웨어와 관련된 지적 재산권 문제는 도전적인 과제.

# 033 컴퓨터를 작동하게 만드는 운영체제

- 운영체제(operating system) : 컴퓨터 하드웨어를 관리하고 다른 프로그램을 실행할 수 있게 하는 소프트웨어의 기초 구조물
- 애플리케이션(application) : 운영체제 위에서 실행되는 프로그램
- 1950년대 초에는 애플리케이션과 운영체제의 구별이 없었음
    - 컴퓨터는 한 번에 한 개의 프로그램만 실행할 수 있을정도로 성능이 제한적이였고, 하드웨어와 강하게 결속된 어셈블리 언어가 이를 제어하였음
    - 비 전문가가 프로그램을 실행하는 것이 비효율적이라고 느껴져서 전문 운영자에게 맡겨졌고, 이런 작업을 자동화 하는 과정에서 운영체제가 개발됨
- 1969년 벨 연구소, 켄 톰프슨과 데니스 리치가 유닉스 운영체제를 개발함
- 운영체제의 기능
    1. 컴퓨터의 자원을 제어하고 할당함
        - 프로세서를 관리하면서 현재 사용중인 프로그램을 스케줄링, 프로그램간의 관계 조절
    2. 주기억 장치를 관리
        - 메모리 스와핑과 같이 효과적인 기법들을 통해 효율적으로 메모리 자원 관리
    3. 보조 기억 장치에 저장된 정보를 관리
        - 파일 시스템(file system) 계층 구조를 제공하여 논리적 구조를 통해 쉽게 제어 가능
    4. 컴퓨터에 연결된 장치들의 활동을 관리하고 조정

# 034 가상 운영체제와 가상 머신

- 운영체제도 하나의 프로그램
- 1991년 리누스 토르발스, 유닉스를 자신의 버전으로 만든 리눅스 개발
- 디스크에 몇개의 운영체제를 두고 어느것을 실행할 것인지 결정하는 멀티 부트
- 다른 운영체제의 관리하에 어떤 운영체제를 가상 운영체제(virtual operating system) 로 실행할 수 있음
    - 호스트는 게스트가 생성하는 요청 중 파일 시스템 접근이나 네트워크 접근 등 운영체제 권한이 필요한 요청을 가로 채고, 이를 수행 한 뒤, 게스트로 되돌아감
    - 물리적 장비를 만들어 출하하는 것 보다 프로그램을 작성해서 배포하는 것이 더 쉽고 유연하기 때문
    - 클라우드 컴퓨팅도 가상 머신에 의존함
        - AWS, Microsoft Azure, Google Cloud platform

# 035 운영체제가 일하는 법

- 부트스트랩 :   자력으로 해내다 라는 관용어구 pulling oneself up by one’s bootstraps에서 나온 표현. 현재는 부팅(booting)이라는 단어로 축약함
    - 부팅 시 운영체제 실행 과정
        1. BIOS(Basic Input Output System)
            - CPU가 전원이 들어오면, ROM에 있는 BIOS 데이터를 읽어옴
        2. POST(Power on self text)
            - Post를 진행하여 하드웨어의 정상적인 작동을 검사한다
        3. BootStrap
            - 부팅 정보를 메모리로 읽어옴
            - MBR(Master Boot Record) : Disk의 첫 번째 섹터
        4. BootLoader
            - Disk에 잇는 운영체제 코드를 메모리로 읽어온다.
        5. Run OS
            - 읽어온 운영체제 명령에 의해 첫 프로세스(Demon)을 즉시 실행하면서, 이벤트 및 인터럽트 처리
- 운영체제는 프로그램에게 자원을 할당하고 사용하던 자원을 회수하는 역할을 함
- 시스템 콜 : 하드웨어와 다른 소프트웨어 간의 인터페이스 제공
    - 표준화 된 방식으로 운영체제의 자원을 이용할 수 있게 해줌.
    - 애플리케이션은 운영체제의 특정한 부분에 통제권을 넘겨 주는 특별한 명령어를 실행함으로써 서비스를 요청함
    - 운영체제는 요청에 포함된 어떤 일이든 처리하고, 통제권과 처리 결과를 에플리케이션에게 돌려줌
    - 운영체제에 서비스를 요청하는 이 진입점을 시스템 콜 이라 함
- 디바이스 드라이버
    - 운영체제와 특정 종류의 하드웨어 장치 간의 가교 역할을 하는 코드
    - 특정 장치가 어떤 일을 하도록 하는 방법을 자세히 알고 있음
    - 운영체제가 일반적인 요청을 보내면, 디바이스 드라이버가 특정 하드웨어가 수행할 수 있도록 적합한 형태로 변환함

# 036 파일 시스템과 블록

- 파일 시스템 : 물리적인 저장 매체를 파일과 폴더의 계층 구조처럼 보이게 하는 부분
- 논리적 구성과 물리적 구현 간의 분리를 보여주는 사례
- 다양한 종류의 장치에 정보를 조직화하여 저장하지만, 운영체제에서는 모두 동일한 인터페이스로 표현함
- 보조 기억 장치 파일 시스템
    - 한 파일이 사용하는 바이트를 다른 파일이 사용하는 바이트와 같은 블록에 저장하지 않음
    - 폴더 엔트리는 파일 이름, 크기, 생성되거나 변경된 날짜와 시간, 권한 등을 담고 있음
    - 구현 방법별로 다른 정보들을 담고 있음
    - 같은 파일이라도 하드 드라이브에 물리적으로 인접하지 않을 수도 있다
    - 웨어 레벨링(wear leveling) : SSD 내부 소프트웨어에서 각 물리적 블록이 얼마나 사용되었는지 파악하고, 같은 횟수로 사용되도록 데이터를 옮김
- 폴더  : 다른 폴더와 파일이 어디에 있는지 정보를 담고 있는 파일
- 새로운 파일을 생성 시 파일 시스템에게 요청함
    - 파일 시스템은 새로운 엔트리를 생성하고, 이름, 날짜 등을 넣고 크기를 0으로 설정함

# 037 파일을 휴지통에 넣을 때 일어나는 일

- 파일 제거하기
    - 그 파일의 폴더 엔트리와 전체 이름이 현재 폴더에서 휴지통이라는 폴더로 복사되고, 원래 폴더 엔트리는 지워짐
    - 파일의 블록과 그 내용은 전혀 바뀌지 않음
    - 이 상태에서 복원한다면, 이 과정을 정반대로 수행해서, 엔트리를 원래 폴더로 복구함
    - 휴지통 비우기→ 휴지통에 있는 폴더 엔트리가 지워지고, 블록은 미사용 목록에 진짜로 추가됨
- 실제 파일을 지우고싶다면, 0과 1로 여러번 덮어 씌우던가, 강한 자성옆에 두어 자성을 없애버리던가, 물리적으로 파괴하던가
- 다른 파일 시스템
    - CD, DVD, USB또한, 또 다른 디스크 드라이브로 나타남
    - 마이크로소프트 FAT(File Allocation Table)이 사실상 표준
    - 표준화된 매체를 이용하여 균일한 인터페이스 사용 가능
- 네트워크 파일 시스템
- RAID 기법

# 038 여러 작업을 수행하는 애플리케이션

- 애플리케이션 : 운영체제를 플랫폼으로 삼아 작업을 수행하는 온갖 종류의 프로그램이나 소프트웨어 시스템을 총칭하는 용어
- 유닉스의 ls, date, cp, mv등도 애플리케이션임
- 워드같은 애플리케이션처럼 훨씬 더 규모가 큰 애플리케이션도 존재
- 브라우저
    - 비동기적 이벤트를 처리하는 애플리케이션
    - 많은 종류의 콘텐츠를 지원
    - 운영체제와 역할이 비슷함

# 039 소프트웨어의 계층 구조

- 소프트웨어 각 계층은 맡은 기능을 구현하고, 그 상위 계층이 서비스에 접근하는데 사용할 수 있도록 추상화 제공
1. 하드웨어 계층 
2. 운영체제 계층 (커널) 
    - kernel : 견과류나 씨앗 등의 알맹이, 또는 핵심적인 부분
    - 하드웨어의 특수한 속성을 숨기고, 애플리케이션에는 특정 하드웨어의 여러가지 세부사항과 독립된 인터페이스 또는 외관을 제공함
    - 리눅스는 온갖 종류의 프로세스에서 작동함. 또한, 각각의 프로세서에서 동일한 운영체제 서비스를 제공함
    - 하드웨어 독립적으로 작동함
    - 애플은 IBM → Intel → ARM으로 프로세서 기반을 변환함. 소프트웨어가 특정 프로세서 아키텍처에 대체로 독립적이라는 것을 증명하는 사례
    - 윈도우는 Wintel이라고 불릴 정도로 인텔 의존도가 높았었으나 요즘은 나아짐
3. 라이브러리 집합
    - 프로그래머 개개인이 기능을 새로 만들어 낼 필요가 없도록 일반적으로 유용한 서비스 제공
    - 라이브러리는 API를 통해 사용할 수 있음
    - 수학적 기능, 날짜, GUI 등 다양한 기능 제공
- 운영체제와 애플리케이션 사이의 경계는 뚜렷하게 정의되어 있지 않음
- 브라우저는 운영체제의 일부가 아님

# 040 요약

- 애플리케이션은 사용자가 원하는 작업을 처리함
- 운영체제는 애플리케이션이 자원을 효율적이고 공평하게 공유하면서, 서로 간섭하지 않을 것을 보장하는 조정자 또는 교통경찰 역할
- 전용 시스템(펌웨어)보다는 리눅스같은 범용 시스템을 사용하는 추세
- 특이한 상황이 아니라면 원래 있는 코드를 사용하는 것이 새로 작성하는 것 보다 쉽고 비용이 적게 들기 때문
- 소프트웨어 시스템은 크고 복잡하며, 종종 버그가 있다

# 041 자바스크립트와 파이썬

- 자바스크립트
    - 모든 브라우저에 포함
    - 언어 자체가 간단하고 유연함
    - 웹 페이지의 다양한 효과에 사용됨
    - 웹 서비스에 제공하는 API를 위한 언어
    - 표준화 되어 있지 않아서 프로그램이 서로 다른 브라우저에서 항상 같은 방식으로 동작하지 않음
    - 현재 브라우저가 아닌 환경에서도 점점 더 많이 사용되고 있음.
- 파이썬
    - 매우 폭 넓은 응용분야에 활용 가능하며 일상적으로 프로그래밍하기 좋음

# 042 프로그래밍 언어의 주요 개념

- 프로그래밍 언어
    - 계산을 일련의 단계로 풀어서 상세히 설명하기 위한 표기법
    - 입력 데이터 읽기, 산술 연산, 계산이 진행됨에 따라 중간 값을 저장하고 가져오며, 이전에 계산한 값을 기반으로 어떻게 진행할 지 결정하고, 그 과정에서 결과를 표시하고, 계산이 완료되면 결과를 저장하기 위한 방법을 제공
    - 구문 규칙(Syntax) : 문법적으로 무엇이 맞고 틀린지 정의하는 규칙
    - 의미 체계(Semantics) : 해당 언어로 표현할 수 있는 모든 것에 대해 명확히 정의된 의미
- 언어의 세가지 측면
    1. 언어 그 자체 : 문장
    2. 코드 라이브러리
    3. 프로그램 실행 환경에 접근하는 기능.

# 043 자바 스크립트로 Hello, World 출력하기

```html
<html>
	<body>
		<script>
			alert("Hello, World!");
		</script>
	</body>
</html>
```

# 044 사용자 이름 받아 출력하기

```jsx
var username;
username = prompt("What's your name?");
alert("Hello, " + username);
```

# 045 루프와 조건문

```jsx
var num, sum;
sum = 0;
num = prompt("Enter new Value, or 0 to end");
while(num != '0'){
	sum = sum + parseInt(num);
	num = prompt("Enter new value, or 0 to end");
}
alert(sum);
```

```jsx
var max, num;
max = 0;
num = prompt("Enter new Value, or 0 to end");
while(num != '0'){
	if(parseInt(num) > parseInt(max)){
		max = num;
	} 
	num = prompt("Enter new Value, or 0 to end");
}
alert("Maximum is " + max);
```

# 046 자바스크립트로 구글 지도에 위치 표시하기

```jsx
function initMap(){
	var latlong = new google.maps.LatLng(38.89768, -77.0365);
	var opts = {
		zoom : 18,
		center : latlong,
		mapTypeId : google.maps.MapTypeId.HYBRID
	};
	var map = new google.maps.Map(
									document.getElementById("map"), opts);
	var marker = new google.maps.Marker({
			position : latlong,
			map : map,
		}
	)
}
```

# 047 자바스크립트는 어떻게 작동할까?

- 브라우저가 웹페이지에서 자바스크립트를 발견하면, 프로그램의 텍스트를 자바스크립트 컴파일러로 전달.
- 이를 어셈블리 언어로 컴파일 후, 시뮬레이터가 자바스크립트 프로그램이 수행하기로 되어있는 모든 기능을 수행함

# 049 더하기 프로그램 만들기

```python
sum = 0
num = input()
while num != '0':
  sum = sum + int(num)
  num = input()
print("The sum is", sum)
```

```python
num = input()
max = num
while num != '0':
  if int(num) > int(max):
    max = num
  num = input()
print("The maximum is", max)
```

# 050 파이썬으로 그래프 그리기

- 파이썬의 가장 뛰어난 강점 중 하나, 방대한 라이브러리 모음 제공
- matplotlib 라이브러리를 이용한 그래프 그리기

```python
import math
import matplotlib.pyplot as plt
log = []; linear = []; nlogn = []; quadratic = [];
for n in range(1, 21):
  linear.append(n)
  log.append(math.log(n))
  nlogn.append(n * math.log(n))
  quadratic.append(n * n)
plt.plot(linear, label = "N")
plt.plot(log, label = "log N")
plt.plot(nlogn, label = "N log N")
plt.plot(quadratic[0:10], label="N * N")
plt.legend()
plt.show()
```

- requests 라이브러리를 이용해 텍스트 애플리케이션 만들기

```python
import requests
url = "https://www.gutenberg.org/files/1342/1342-0.txt" 
pandp = requests.get(url).text
start = pandp.find("It is a truth")
pandp = pandp[start:]
end = pandp.find(".")
print(pandp[0:end+1])
```
