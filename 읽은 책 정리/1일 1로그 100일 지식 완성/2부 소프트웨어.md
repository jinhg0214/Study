# 018 알고리즘과 초콜릿 케이크 레시피

- 소프트웨어는 음식을 만드는 레시피와 유사함
    - 요리에 필요한 재료, 수행해야하는 작업 순서, 예상되는 결과를 열거
    - 소프트웨어는 연산에 필요한 데이터를 명시, 데이터에 대해 수행할 작업을 자세히 설명
- 알고리즘(algorithm)은결과를 정확하게 계산하도록 보장된 일련의 단계
    - 한치의 모호함도 있어서는 안된다
    - 입력 데이터가 어떤 유형인지
    - 모든 가능한 상황을 다루어야 하고, 다음에 무엇을 해야 할 지 모르는 상황이 발생하면 안됨
    - 언젠가는 멈춰야함
    - 지능이나 상상력이 없는 개체가 수행하더라도 연산의 의미와 수행 방법에 의심의 여지가 없을 정도로 상세하고 정확하게 일련의 연산을 명시해야함
    - 알고리즘의 효율성은 처리 데이터 양에 따라 계산에 소요되는 시간을 표현하는 방법

# 019 반에서 가장 키 큰 사람 찾기 : 선형 알고리즘

- 키가 가장 큰 사람을 찾는법
    
    ```
    set max to 0
    for each height on the list
    	if max is smaller than height
    		then max is height
    print max 
    ```
    
    - 중복되는 값이 있을땐?
    - 키가 같은 사람들의 무리 중에서 사람 수가 가장 많은 무리를 찾는 방법은?
    - 자료 구조(data structure) : 계산 과정에서 필요한 정보를 표현하는 방법
    - 알고리즘과 컴퓨터는 모든 가능한 상황을 처리해야함
- 얼마나 효율적으로 작동하느냐가 알고리즘에서 중요한 특성임
- 선형 시간(Linear-time) 계산 시간이 데이터의 양에 정비례하거나 선형적으로 비례함
    - 대부분의 선형 알고리즘이 동일한 기본 형태를 가짐
    ```
    1. 초기화
    2. 각 항목을 차례로 검사하고, 항목에 대해 간단한 계산을 수행
    3. 작업을 끝내기 위한 단계 수행
    ```

# 020 10억개의 전화번호에서 이름 찾기 : 이진 검색

- 정렬되어 있다면 이진 검색을 적용할 수 있음
- 이진 검색(binary search)
    - 각 확인 또는 비교 단계를 거치면서 항목이 두 그룹으로 나뉘고, 한쪽 그룹은 다음 고려 대상에서 제외함.
    - 분할 정복(divide and conquer)이라는 일반적인 전략의 한 가지 예
    - 수행해야하는 일의 양이 데이터의 양이 증가하는 것에 비해 천천히 증가함

# 021 검색을 쉽게 만드는 정렬 : 선택 정렬 vs 퀵 정렬

- 핵심적인 알고리즘 문제인 정렬(sorting)
    - 항목을 순서대로 배열해서 검색이 빨리 실행될 수 있도록 해줌

## 선택 정렬(selection sort)

- 아직 정렬되지 않은 항목 중에서 다음 이름을 계속해서 선택함

```
1. 주어진 배열 중에서 최소값을 찾는다
2. 그 값을 맨 앞에 위치한 값과 교체한다
3. 맨 처음 위치를 뺸 나머지 리스트를 같은 방법으로 교체한다
4. 하나의 원소만 남을 때 까지 위의 1~3 과정을 반복한다
```

- 시간 복잡도는 O(n^2)

## 퀵 정렬(quicksort)

- 분할 정복의 한 사례

```
1. 리스트 안에서 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot)이라 한다
2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고, 
   피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다
3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다
   - 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다
   - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다
4. 부분 리스트들이 더 이상 분할이 불가능할 때 까지 반복한다
	 
```

- 속도가 빠르다.
- 시간 복잡도는 O(nlog_2 n)을 가짐.
- 불균형 분할이 일어나면 오히려 수행시간이 더 오래걸릴수도 있다

# 022 10개 도시를 최단거리로 여행하는 법

- 지수 복잡도(Exponential) : 실생활에서 자주 등장하지만 효율이 특히 낮음
    - 지수 알고리즘은 사실상 모든 가능한 경우를 하나씩 시도해 봐야한 하는 상황에서 발생
- P-NP 문제
    - Polynomial. 다항 시간 내에 해결 가능
    - Nondeterministric Polynomial : 비결정적 다항
    - ex) 여행하는 외판원 문제
        - 아직도 최단 경로를 찾는 방법은 모든 가능한 경로를 시도해 보는 것 밖에 없음
    - 즉, 가능한 모든 해법을 완전 탐색하는 것 보다 더 효율적으로 풀 방법이 없다는 뜻

# 023 요약

- 컴퓨터과학 분야에서는 오랜시간 ‘얼마나 빨리 계산할 수 있는가?’에 관한 개념을 정리함
- 실행 시간을 표현하는 빅 오 표기법(Big-O notation)이 그 결과임
- 알고리즘끼리 비교하거나 어떤 계싼의 실행 가능성을 추론하는 좋은 방법
- 이론상으로는 검색 엔진이 하는 일도 간단함
    - 웹 페이지를 수집하고, 검색하기 쉽게 정보를 조직화 하고, 효율적으로 정보를 검색하는것
    - 그러나 작업의 규모가 엄청나게 크기 때문에, 다양한 알고리즘과 프로그램 기법이 적용됨

# 024 알고리즘은 이상, 프로그램은 현실

- 알고리즘은 추상적이고 이상적인 절차를 기술 한 것, 구현에 필요한 세부사항과 현실적인 고려사항을 무시함
- 프로그램은 실제 컴퓨터가 과제를 완료하기 위해 수행해야 하는 모든 단계를 구체적으로 서술함
    - 하나 이상의 알고리즘이 컴퓨터가 직접 처리할 수 있는 형태로 표현된 것
    - 불충분한 메모리, 제한된 프로세서 속도, 유효하지 않거나 악의적으로 잘못된 데이터 입력, 하드웨어 결함, 네트워크 연결 분량, 휴먼 에러 등의 문제를 고려
- 컴퓨터의 자원 관리 일 또한 어려움. 이는 운영체제가 처리

# 025 다른 프로그램을 처리하기 위한 프로그램

- 최초에는 천공카드를 이용하여 프로그래밍하여, 수정하기 매우 어려웠음
- 에드삭(윌스크) : 1949년 첫 번째 프로그램 내장식 디지털 컴퓨터
    - 다른 프로그램을 처리하기 위한 프로그램
- 어셈블러(assembler) 특정 처리를 수행하는 프로그램.
    - 다른 프로그래머가 사전에 작성했던 프로그램에서 필요한 부분을 모으는 역할을 하기 때문에 붙여진 이름
    - 프로그래머가 명령어를 추가하거나 삭제할 때, 변경 기록을 직접 관리하는 대신, 어셈블러가 각 명령어와 데이터 값이 메모리상 어느 위치에 있는지 파악해줌
    - 특정 프로세서 아키텍처에서 사용되는 어셈블리 언어는 그 아키텍처에 특화된 언어
    - 프로세서 명령어와 일대일로 연결되고, 명령어가 이진수로 인코딩 되는 특정한 방식과 메모리에 정보가 배치되는 방식을 알고 있음

# 026 고수준 언어에서 프로그래밍 실행까지

- 특정 아키텍처에 독립적인 고수준 프로그래밍 언어가 개발됨
    - 고수준 언어로 작성된 코드는 번역기 프로그램(컴파일러)을 통해 대상 프로세서의 어셈블리 언어로 변환되고, 어셈블러에 의해 비트로 변환되어 메모리에 로드되고 실행됨
    - 장점
        1. 사람이 표현하는 방식에 가까운 용어로 계산 과정을 작성할 수 있음
        2. 프로그램을 효율적으로 짜기 위해 특정 프로세서의 명령어 레퍼토리를 알아야 할 필요가 없음
        3. 특정 아키텍처에 종속되지 않음
        4. 컴파일 단계는 몇 가지 명백한 에러를 미리 점검하게 해줌
- 초기에는 컴파일러가 숙련된 어셈블리 언어 프로그래머보다 효율적이지 못하였음

### 포트란Fortran

- Formular Translation 수식 변환에서 유래한 이름
- IBM팀에서 개발하였고, 과학 공학 분야에서 계산을 표현하는데 사용함

### 코볼COBOL

- Common Business Oriented Language
- 사무 데이터 처리 목적으로 사용되었고, 재고 관리, 송장 작성, 급여 계산 등에 사용됨
- 국내 은행권에서 아직도 사용하고있음

### 베이직BASIC

- Beginner’s All-purpose Symbolic Instruction Code
- 프로그래밍 교육을 위한 쉬운 언어
- 개인용 컴퓨터에서 사용할 수 있는 첫 번째 고수준 언어

# 027 작문과 비슷한 프로그래밍

- 포트란, 코볼, 베이직이 성공했던 이유는 특정 응용 분야에 집중했기 때문
- 1970년대부터는 시스템 프로그래밍 용도로, 즉 어셈블러, 컴파일러, 텍스트 편집기 같은 프로그래머 도구와 심지어 운영체제까지 작성할 목적으로 사용할 언어들이 만들어졌음

### C언어

- 1973년 벨 연구소, 데니스 리치가 개발
- 가장 폭 넓게 사용되며 가장 있기있는 언어

### C++

- 1980년대 들어서는 규모가 매우 큰 프로그램의 복잡성 관리를 도울 의도로 설계된 언어들이 개발됨
- 벨 연구소, 비야네 스트로스트룹이 개발
- 대부분의 컴퓨터에서 사용되는 주요 프로그램들이 C, C++, Obj C로 개발되었음

### Java

- 1990년대 WWW 성장에 대응하여 더 많은 언어가 개발되었음.
- 썬 마이크로시스템즈에서  일하던 제임스 고슬링이 개발함
- 초기 자바의 적용 대상은 속도는 그다지 중요하지 않지만 유연성이 중요한 임베디드 시스템 타겟
- 현재 자바는 안드로이드 앱을 작성하는 주요 언어기도 함

### Javascript

- 1995년, 넷스케이프에서 근무하던 브렌던 아이크가 개발
- 자바와는 상관 없음
- 처음부터 웹 페이지의 동적인 효과를 구현하기 위해 브라우저 내부에서 사용할 목적으로 개발됨

### Python

- 1991, 네덜란드 암스테르담의 CWI에서 일하던 귀도 반 로섬이 개발
- 문장을 그룹화 하는데 중괄호 대신 들여쓰기 이용함
- 가독성에 초점을 두고 설계됨

# 028 구글 같은 서비스는 어떻게 개발할까?

- 대규모 프로그래밍은 무엇을 해야할지 파악하고, 넓은 명세부터 시작해서 점차 작은 부분으로 적절히 나누고, 각 부분을 작업하면서 전체적으로 일관되어 있는지 확인해야 한다
- 다른 프로그래머들이 작성한 부분들이 함께 잘 작동하는지 확인하는 일은 어려운데, 이걸 바로잡지 못하면 에러가 발생할 소지가 크다

### 라이브러리, 인터페이스, 개발 키트

- 다른 사람들이 만들어놓은 여러 가지 구성 요소를 바로 구해서 사용함
- 프로그래밍 작업의 대부분은 이미 있는 구성 요소를 이해하고자신만의 방식으로 이어 붙이는 것
- 함수 매커니즘 : 어떤 프로그래머가 유용한 작업을 수행하는 코드를 작성하면, 다른 프로그래머가 그 내부 작동 방식을 모르더라도 프로그램에 사용할 수 있는 형태로 코드를 패키지화
- 연관된 함수들의 모음을 보통 라이브러리라고 함
- 함수 라이브러리가 제공하는 서비스는 애플리캐이션 프로그래밍 인터페이스, 즉 API로 프로그래머에게 제공됨
- 대규모 시스템은 프로그래머들이 복잡한 소프트웨어 라이브러리를 잘 다룰 수 있도록 소프트웨어 개발 키트, 즉 SDK를 포함함

### 버그

- 발생할 수 있는 경우를 깜빡하고 처리하지 못했거나, 어떤 조건을 평가하기 위한 논리 테스트나 산술 테스트를 잘못 작성했거나, 잘못된 공식을 사용했거나, 프로그램이나 프로그램의 특정 부분에 할당된 영역 밖에 있는 메모리에 접근했거나, 특정 종류의 데이터에 잘못된 연산을 적용했거나, 사용자 입력이 적합한지 검사하지 못한 경우 등
- 두 함수가 역함수 관계라면, 두 함수를 차례로 통과시키면 원래 값이 되어야함

# 029 구글과 오라클의 저작권 소송

- 지적 재산권(intellectual property) : 다양한 종류의 무형 자산. 소프트웨어도 지적 재산권 중 하나
- 영업 비밀(trade secret) : 지적재산권은 소유자만 그 비밀을 보유하고, 기밀 유지 협약서 같은 법적 구속력이 있는 계약에 의해서만 다른이에게 공개된다
- 상표(trademark) : 회사의 상품이나 서비스를 구별해주는 단어나 문구, 이름, 로고, 특정 색상 등
- 저작권(copyright) : 창작 표현물을 보호함. 저작권은 다른 이들이 복제하지 못하도록 창작물을 보호하며, 창작자에게 제한된 기간에 걸쳐 작품을 확용하고 수익을 얻을 권리를 줌
- 특허(patent) : 발명에 대한 법적 보호를 제공. 저작권은 표현물만 보호한다면, 특허는 코드가 포함할 수 있는 어떤 독창적인 아이디를 보호함.
    - 특허 괴물(patent troll) : 허가 없이 특허를 침해중인 다른 기업에게 소송을 제기하기 위해 특허에 대한 권리를 취득
- 라이선스(license) : 제품을 사용할 권한을 승인하는 법적 합의.
    - 최종 사용자 라이선스 동의(End User License Agrement : EULA)

# 030 기술 표준의 중요성

- 표준(standard) : 어떤 기술적 산물이 어떻게 만들어지고 어떻게 작동하도록 되어있는지 명확하고 상세하게 기술 한 것
- 보통 정부 기관이나 컨소시엄같은 준중립적 단체에 의해 개발되고 유지됨
- 서로 경쟁관계에 있는 표준도 있음.
- 소프트웨어에도 많은 표준이 있음. ex) 아스키코드, 유니코드 등
- 표준은 상호운용성을 보장하고 공개경쟁이 이루어지도록 하는데 결정적인 요소임

# 031 자유로운 소프트웨어 오픈소스

- 프로그래머가 작성하는 코드는 소스 코드(source code)
- 소스코드를 프로세서에서 실행하기에 적합한 형태로 컴파일 한 결과를 오브젝트 코드(object code)라고 함
- 대부분의 상용 소프트웨어는 오브젝트 코드 형태로만 배포됨
    - 너무 많은 변환 과정을 거쳤기 때문에, 원래 소스코드와 조금이라도 비슷하게 복원하거나, 수정이 대개 불가능하기 때문

### 오픈소스(open source)

- 연구와 개선 활동을 위해 다른 사람들도 소스 코드를 자유롭게 사용할 수 있도록 하는 대안을 일컫는 용어
- 1983년 리처드 스톨만 GNU 프로젝트
    - 중요한 소프트웨어 시스템의 무료 공개 버전을 만드는것
    - 자유 소프트웨어 재단 비영리 단체 개설
    - GNU GPL라이선스에 따라 배포
- GPL은 라이선스가 적용된 소프트웨어를 자유롭게 사용할 수 있다고 명시하는데, 만약 소프트웨어가 다른 누군가에게 배포되면 그 배포판도 똑같이 ‘어떤 용도로 자유로운’ 라이선스를 적용해서 소스코드를 사용할 수 있게 해야한다.
- GNU 프로젝트는 기업, 단체, 개인에게서 지원을 받고, 수많은 프로그램 개발 도구와 애플리케이션을 만들어냄
- 리눅스 운영체제도 오픈소스 프로젝트

# 032 요약

- 프로그래밍 언어는 컴퓨터에 무엇을 해야할 지 알려줄 때 쓰는 언어
- 어떤 언어도 단독으로 모든 프로그래밍 과제에 이상적이지는 않음
- 프로그래밍 언어는 꾸준히 증가하는 하드웨어 자원을 활용하도록 진화하였음
- 소프트웨어와 관련된 지적 재산권 문제는 도전적인 과제.

# 033 컴퓨터를 작동하게 만드는 운영체제

- 운영체제(operating system) : 컴퓨터 하드웨어를 관리하고 다른 프로그램을 실행할 수 있게 하는 소프트웨어의 기초 구조물
- 애플리케이션(application) : 운영체제 위에서 실행되는 프로그램
- 1950년대 초에는 애플리케이션과 운영체제의 구별이 없었음
    - 컴퓨터는 한 번에 한 개의 프로그램만 실행할 수 있을정도로 성능이 제한적이였고, 하드웨어와 강하게 결속된 어셈블리 언어가 이를 제어하였음
    - 비 전문가가 프로그램을 실행하는 것이 비효율적이라고 느껴져서 전문 운영자에게 맡겨졌고, 이런 작업을 자동화 하는 과정에서 운영체제가 개발됨
- 1969년 벨 연구소, 켄 톰프슨과 데니스 리치가 유닉스 운영체제를 개발함
- 운영체제의 기능
    1. 컴퓨터의 자원을 제어하고 할당함
        - 프로세서를 관리하면서 현재 사용중인 프로그램을 스케줄링, 프로그램간의 관계 조절
    2. 주기억 장치를 관리
        - 메모리 스와핑과 같이 효과적인 기법들을 통해 효율적으로 메모리 자원 관리
    
     3. 보조 기억 장치에 저장된 정보를 관리
    
    - 파일 시스템(file system) 계층 구조를 제공하여 논리적 구조를 통해 쉽게 제어 가능
    1. 컴퓨터에 연결된 장치들의 활동을 관리하고 조정