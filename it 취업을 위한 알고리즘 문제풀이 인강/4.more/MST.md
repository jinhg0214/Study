# Spanning Tree
- spanning(기간, 폭)
- 그래프 내의 모든 정점을 포함하는 트리, 신장 트리, 스패닝 트리
- 스패닝 트리는 그래프의 최소 연결 부분 그래프(간선이 가장 적음)
- n개의 정점을 가진 그래프는 n-1개의 간선을 가짐
- DFS, BFS를 이용하여 그래프에서 Spanning Tree를 찾을 수 있음

# MST(Minimum Spanning Tree)
- Spanning Tree 중에서 사용된 간선들의 가중치의 합이 최소인 트리
- n개의 정점, n-1개의 간선
- 사이클이 포함되어서는 안된다!!

# MST의 구현 방법

## Kruskal MST 알고리즘
- 간선을 선택하는 알고리즘
1. 그래프의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 <em>사이클을 형성하지 않는</em> 간선을 선택
3. 해당 간선을 현재의 MST의 집합에 추가
4. n-1개의 간선이 선택되면 종료
- 시간 복잡도 O(elog_2^e)

## Prim MST 알고리즘
- 정점을 선택하는 알고리즘
1. 시작 정점을 MST에 넣음
2. 앞 단계에서 만들어진 MST집합에 인접한 정점들 중에서, 가중치가 가장 낮은 간선을 선택하여 트리를 확장함. 
3. 트리가 N-1개의 간선을 선택할 때 까지 반복
- 시간 복잡도 O(n^2)

# Dijkstra 알고리즘
- 한 노드에서, 다른 노드까지의 가장 작은 가중치를 가지는 경로를 검색하는 알고리즘.
- MST가 아님!!!
- 간선값이 양수일때 최단거리를 구하는 알고리즘
1. 출발점으로부터 최단거리를 저장할 배열 d[v]를 만들고, 출발 노드는0, 나머지는 INF값을 채움   
2. 출발 노드를 기준으로, 연결된 간선의 가중치를 비교.
3. 방문하지 않은 노드들 중에서 가장 비용이 적은 간선을 선택.
4. 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여, 최소 비용을 갱신
5. 위 과정을 반복

# Bellman-Ford 알고리즘
- 최단경로 알고리즘
- 사이클을 포함할 수 없기 때문에, |v|-1개의 간선만 사용 가능
- 음수 간선 순환이 있는 경우, 이를 감지할 수 있음
- 그러나 Dijkstra보다 느림 O(V*E)
 1. 첫 노드를 제외한 모든 노드들의 d[v]를 INF로 초기화
 2. N-1번 만큼 반복
    2-1. 전체 간선 E개를 하나씩 확인
    2-2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여, 최단 거리 테이블을 갱신
 3. 음수 간선 순환이 발생하는지 체크하고 싶다면 2번의 과정을 한번 더 수행.   
 (이때 테이블이 갱신된다면, 음수 간선 순환이 존재하는것임)