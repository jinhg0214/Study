#include <iostream>
#include <string>
using namespace std;

int main() {
	// freopen_s(new FILE*, "input.txt", "r", stdin);

	char table[26];
	for (int i = 0; i < 26; i++) {
		table[i] = 'a' + i + 13;
		if (table[i] > 'z' || table[i] < 0) { // 오버플로우인 경우 
			table[i] -= 26;
		}
	}

	string s;
	getline(cin, s);

	for (int i = 0; i < s.length(); i++) {
		// 알파벳이 아닌경우
		if (!isalpha(s[i])) {
			cout << s[i];
		}
		// 소문자인 경우
		else if (islower(s[i])) {
			cout << table[s[i] - 'a']; // s[i] - 'a'는 0~26의 숫자로 치환됨
		}
		// 대문자인 경우
		else {
			cout << char(table[s[i] - 'A'] - 32); 
			// 32 를 빼주는 이유는 'a' 가 97, 'A'가 65이기 때문
			// 즉 'A'에서 -32를 하면 소문자로 변환할 수 있음.
		}
	}

	return 0;
}

/*
입력 :
	첫째 줄에 알파벳 대문자, 소문자, 공백, 숫자로만 이루어진 문자열 S가 주어진다.
	S의 길이는 100을 넘지 않는다.
출력 :
	첫째 줄에 S를 ROT13으로 암호화한 내용을 출력한다.

ROT13이란, 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.
예를 들어, "Baekjoon Online Judge"를 ROT13으로 암호화하면 "Onrxwbba Bayvar Whqtr"가 된다.
ROT13은 알파벳 대문자와 소문자에만 적용할 수 있다. 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다.
예를 들어, "One is 1"을 ROT13으로 암호화하면 "Bar vf 1"이 된다.



풀이 :
	1. 먼저 알파벳 대응 테이블을 만든다
	| a | b | c | d | ... | x | y | z |
	| n | o | p | q | ... | k | l | m |
	(테이블을 만들면, 짧은 문자열을 만들땐 느리지만 긴 문자열을 처리할땐 빠름)

	2. 문자열을 입력받아 각 문자를 테이블을 보고 치환함
		2-1. 알파벳이 아니면 그대로 내보냄
		2-2. 알파벳이라면 대소문자를 판별함
			2-2-1. 소문자라면 
				테이블을 보고 치환함
			2-2-2. 대문자라면
				소문자 테이블을 보고 치환 후 대문자로 전환해줌
				

	
	알파벳 소문자는 소문자로, 대문자는 대문자로 남아있어야한다
	아스키 코드를 이용.
	'a' <= 알파벳 <= 'z' 인 경우 (알파벳 + 13). 이때 z를 초과한 경우 다시 앞으로 돌림
	대문자도 마찬가지

* 알파벳 + 13 을 하는 경우. 아스키 코드는 127을 넘어가면 오버플로우가 남
대문자는 잘 처리되나, 소문자는 별도의 처리가 필요함.
*/
